-- Curatify Oracle 19c 데이터베이스 초기화 스크립트

-- Oracle에서는 데이터베이스 대신 스키마를 사용
-- XE 인스턴스는 이미 생성되어 있음

-- 시퀀스 생성
CREATE SEQUENCE USERS_SEQ START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE RSS_URLS_SEQ START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE RSS_FEEDS_SEQ START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE PAPERS_SEQ START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE CS_PAPER_CATEGORIES_SEQ START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE CS_PAPER_CATEGORY_RELATIONS_SEQ START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE PAPER_CONTENT_SEQ START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE USER_LIBRARY_SEQ START WITH 1 INCREMENT BY 1;
CREATE SEQUENCE USER_INTERESTS_SEQ START WITH 1 INCREMENT BY 1;

-- 사용자 테이블 생성
CREATE TABLE USERS (
    ID NUMBER PRIMARY KEY,
    EMAIL VARCHAR2(255) UNIQUE NOT NULL,
    PASSWORD VARCHAR2(255) NOT NULL,
    NAME VARCHAR2(255),
    IS_VERIFIED NUMBER(1) DEFAULT 0 CHECK (IS_VERIFIED IN (0, 1)),
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 사용자 테이블 트리거 (AUTO_INCREMENT 대체)
CREATE OR REPLACE TRIGGER USERS_TRIGGER
    BEFORE INSERT ON USERS
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT USERS_SEQ.NEXTVAL INTO :NEW.ID FROM dual;
    END IF;
    :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
END;
/

-- updated_at 자동 업데이트 트리거
CREATE OR REPLACE TRIGGER USERS_UPDATE_TRIGGER
    BEFORE UPDATE ON users
    FOR EACH ROW
BEGIN
    :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
END;
/

-- RSS URL 테이블 생성
CREATE TABLE RSS_URLS (
    ID NUMBER PRIMARY KEY,
    TYPE VARCHAR2(20) NOT NULL CHECK (TYPE IN ('youtube', 'normal')),
    URL VARCHAR2(500) NOT NULL,
    USER_ID NUMBER NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    DELETED_AT TIMESTAMP,
    CONSTRAINT FK_RSS_URLS_USER_ID FOREIGN KEY (USER_ID) REFERENCES USERS(ID) ON DELETE CASCADE
);

-- RSS URL 테이블 트리거
CREATE OR REPLACE TRIGGER RSS_URLS_TRIGGER
    BEFORE INSERT ON RSS_URLS
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT RSS_URLS_SEQ.NEXTVAL INTO :NEW.ID FROM dual;
    END IF;
    :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER RSS_URLS_UPDATE_TRIGGER
    BEFORE UPDATE ON RSS_URLS
    FOR EACH ROW
BEGIN
    :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
END;
/

-- 인덱스 생성
CREATE INDEX IDX_RSS_URLS_USER_ID ON RSS_URLS(USER_ID);
CREATE INDEX IDX_RSS_URLS_TYPE ON RSS_URLS(TYPE);
CREATE INDEX IDX_RSS_URLS_DELETED_AT ON RSS_URLS(DELETED_AT);
CREATE INDEX IDX_RSS_URLS_USER_DELETED_AT ON RSS_URLS(USER_ID, DELETED_AT);

-- RSS Feed 테이블 생성
CREATE TABLE RSS_FEEDS (
    ID NUMBER PRIMARY KEY,
    TITLE VARCHAR2(500) NOT NULL,
    SUMMARY CLOB,
    WRITED_AT TIMESTAMP NOT NULL,
    ORIGINAL_URL VARCHAR2(500),
    RSS_URL_ID NUMBER NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT FK_RSS_FEEDS_RSS_URL_ID FOREIGN KEY (RSS_URL_ID) REFERENCES RSS_URLS(ID)
);

-- RSS Feed 테이블 트리거
CREATE OR REPLACE TRIGGER RSS_FEEDS_TRIGGER
    BEFORE INSERT ON RSS_FEEDS
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT RSS_FEEDS_SEQ.NEXTVAL INTO :NEW.ID FROM dual;
    END IF;
    :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER RSS_FEEDS_UPDATE_TRIGGER
    BEFORE UPDATE ON RSS_FEEDS
    FOR EACH ROW
BEGIN
    :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
END;
/

-- 인덱스 생성
CREATE INDEX IDX_RSS_FEEDS_RSS_URL_ID ON RSS_FEEDS(RSS_URL_ID);
CREATE INDEX IDX_RSS_FEEDS_WRITED_AT ON RSS_FEEDS(WRITED_AT);
CREATE INDEX IDX_RSS_FEEDS_CREATED_AT ON RSS_FEEDS(CREATED_AT);

-- Papers 테이블 생성
CREATE TABLE PAPERS (
    ID NUMBER PRIMARY KEY,
    TITLE VARCHAR2(500) NOT NULL,
    AUTHORS CLOB,
    UPDATE_DATE TIMESTAMP,
    URL VARCHAR2(500),
    ABSTRACT CLOB NOT NULL,
    SUMMARY CLOB,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Papers 테이블 트리거
CREATE OR REPLACE TRIGGER PAPERS_TRIGGER
    BEFORE INSERT ON PAPERS
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT PAPERS_SEQ.NEXTVAL INTO :NEW.ID FROM dual;
    END IF;
    :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER PAPERS_UPDATE_TRIGGER
    BEFORE UPDATE ON PAPERS
    FOR EACH ROW
BEGIN
    :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
END;
/

-- 인덱스 생성
CREATE INDEX IDX_PAPERS_UPDATE_DATE ON PAPERS(UPDATE_DATE);
CREATE INDEX IDX_PAPERS_CREATED_AT ON PAPERS(CREATED_AT);

-- Paper Categories 테이블 생성
CREATE TABLE CS_PAPER_CATEGORIES (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100) UNIQUE NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- CS Paper Categories 테이블 트리거
CREATE OR REPLACE TRIGGER CS_PAPER_CATEGORIES_TRIGGER
    BEFORE INSERT ON CS_PAPER_CATEGORIES
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT CS_PAPER_CATEGORIES_SEQ.NEXTVAL INTO :NEW.ID FROM dual;
    END IF;
    :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER CS_PAPER_CATEGORIES_UPDATE_TRIGGER
    BEFORE UPDATE ON CS_PAPER_CATEGORIES
    FOR EACH ROW
BEGIN
    :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
END;
/

-- 인덱스 생성
CREATE INDEX IDX_CS_PAPER_CATEGORIES_NAME ON CS_PAPER_CATEGORIES(NAME);

-- Paper-Category 관계 테이블 생성 (N:M 관계)
CREATE TABLE CS_PAPER_CATEGORY_RELATIONS (
    ID NUMBER PRIMARY KEY,
    PAPER_ID NUMBER NOT NULL,
    CATEGORY_ID NUMBER NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT FK_CS_PAPER_CATEGORY_RELATIONS_PAPER_ID FOREIGN KEY (PAPER_ID) REFERENCES PAPERS(ID) ON DELETE CASCADE,
    CONSTRAINT FK_CS_PAPER_CATEGORY_RELATIONS_CATEGORY_ID FOREIGN KEY (CATEGORY_ID) REFERENCES CS_PAPER_CATEGORIES(ID) ON DELETE CASCADE,
    CONSTRAINT UNIQUE_PAPER_CATEGORY UNIQUE (PAPER_ID, CATEGORY_ID)
);

-- CS Paper Category Relations 테이블 트리거
CREATE OR REPLACE TRIGGER CS_PAPER_CATEGORY_RELATIONS_TRIGGER
    BEFORE INSERT ON CS_PAPER_CATEGORY_RELATIONS
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT CS_PAPER_CATEGORY_RELATIONS_SEQ.NEXTVAL INTO :NEW.ID FROM dual;
    END IF;
END;
/

-- 인덱스 생성
CREATE INDEX IDX_CS_PAPER_CATEGORY_RELATIONS_PAPER_ID ON CS_PAPER_CATEGORY_RELATIONS(PAPER_ID);
CREATE INDEX IDX_CS_PAPER_CATEGORY_RELATIONS_CATEGORY_ID ON CS_PAPER_CATEGORY_RELATIONS(CATEGORY_ID);

-- Paper Content 테이블 생성 (논문 상세 내용)
CREATE TABLE PAPER_CONTENT (
    ID NUMBER PRIMARY KEY,
    CONTENT_TITLE VARCHAR2(500) NOT NULL,
    CONTENT CLOB NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    ORDER_NUM NUMBER NOT NULL,
    PAPER_ID NUMBER NOT NULL,
    CONSTRAINT FK_PAPER_CONTENT_PAPER_ID FOREIGN KEY (PAPER_ID) REFERENCES PAPERS(ID) ON DELETE CASCADE,
    CONSTRAINT UNIQUE_PAPER_CONTENT UNIQUE (PAPER_ID, ORDER_NUM)
);

-- Paper Content 테이블 트리거
CREATE OR REPLACE TRIGGER PAPER_CONTENT_TRIGGER
    BEFORE INSERT ON PAPER_CONTENT
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT PAPER_CONTENT_SEQ.NEXTVAL INTO :NEW.ID FROM dual;
    END IF;
END;
/

-- 인덱스 생성
CREATE INDEX IDX_PAPER_CONTENT_PAPER_ID ON PAPER_CONTENT(PAPER_ID);
CREATE INDEX IDX_PAPER_CONTENT_CREATED_AT ON PAPER_CONTENT(CREATED_AT);

-- User Library 테이블 생성 (사용자 논문 라이브러리)
CREATE TABLE USER_LIBRARY (
    ID NUMBER PRIMARY KEY,
    USER_ID NUMBER NOT NULL,
    PAPER_ID NUMBER NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT FK_USER_LIBRARY_USER_ID FOREIGN KEY (USER_ID) REFERENCES USERS(ID) ON DELETE CASCADE,
    CONSTRAINT FK_USER_LIBRARY_PAPER_ID FOREIGN KEY (PAPER_ID) REFERENCES PAPERS(ID) ON DELETE CASCADE,
    CONSTRAINT UNIQUE_USER_PAPER UNIQUE (USER_ID, PAPER_ID)
);

-- User Library 테이블 트리거
CREATE OR REPLACE TRIGGER USER_LIBRARY_TRIGGER
    BEFORE INSERT ON USER_LIBRARY
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT USER_LIBRARY_SEQ.NEXTVAL INTO :NEW.ID FROM dual;
    END IF;
END;
/

-- 인덱스 생성
CREATE INDEX IDX_USER_LIBRARY_USER_ID ON USER_LIBRARY(USER_ID);
CREATE INDEX IDX_USER_LIBRARY_PAPER_ID ON USER_LIBRARY(PAPER_ID);
CREATE INDEX IDX_USER_LIBRARY_CREATED_AT ON USER_LIBRARY(CREATED_AT);

-- User Interests 테이블 생성 (사용자 관심사)
CREATE TABLE USER_INTERESTS (
    ID NUMBER PRIMARY KEY,
    USER_ID NUMBER NOT NULL,
    CONTENT VARCHAR2(300) NOT NULL,
    CREATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    UPDATED_AT TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT FK_USER_INTERESTS_USER_ID FOREIGN KEY (USER_ID) REFERENCES USERS(ID) ON DELETE CASCADE
);

-- User Interests 테이블 트리거
CREATE OR REPLACE TRIGGER USER_INTERESTS_TRIGGER
    BEFORE INSERT ON USER_INTERESTS
    FOR EACH ROW
BEGIN
    IF :NEW.ID IS NULL THEN
        SELECT USER_INTERESTS_SEQ.NEXTVAL INTO :NEW.ID FROM dual;
    END IF;
    :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
END;
/

CREATE OR REPLACE TRIGGER USER_INTERESTS_UPDATE_TRIGGER
    BEFORE UPDATE ON USER_INTERESTS
    FOR EACH ROW
BEGIN
    :NEW.UPDATED_AT := CURRENT_TIMESTAMP;
END;
/

-- 인덱스 생성
CREATE INDEX IDX_USER_INTERESTS_USER_ID ON USER_INTERESTS(USER_ID);
CREATE INDEX IDX_USER_INTERESTS_CREATED_AT ON USER_INTERESTS(CREATED_AT);

-- Oracle에서는 권한 설정이 다름 (사용자가 이미 존재한다고 가정)
-- 테이블 생성 확인
SELECT TABLE_NAME FROM USER_TABLES ORDER BY TABLE_NAME;
